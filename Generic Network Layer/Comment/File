
* Network Manger'ı yazmaya başladık *

- https://jsonplaceholder.typicode.com -> Bu bizim base URL'miz
- /users -> Bu da bizim path'miz yani endPointimiz, büyük projelerde çok fazla bulunur
- Endpoint'lerimi handle atmek için bir Enpoint adında bir file oluşturuyoruz.

- Benim baseURL'den data çekmek için bir methoda ihtiyacım var (get,post,patch,delete...)
- HTTP Metodları bunlar.



* Endpoint Dosyasını oluşturyoruz *

- İçeride bize lazım olan tüm yapıları oluşturuyouruz
- 1 HTTPMethod (Get, Post, Delete, Patch)
- 2 EndPoint (BaseURL, path, HTTPMethod, Headers, request())
- 3 NetworkError

- Request fonksiyonumuzu oluşturuyoruz bu bize bir URLRequest döndürücek.
- İçersinde component bileşenlerimizi veriyoruz(baseURL, HTTPMethod, Header, path)



* Network Menager'imizi yazmaya başlayabiliriz *

- NetworkManager için bir adet Protocolde oluşturuoyuz ve Classımız bu Protocılü conform edecek.
-Şimdi ilk olarak NetworkManagerProtocol içersinde bulunan request adlı fonksiynu generic hale getirelim özelleşterelim
- T type olmalı ve Codable'ye conform edecek
- Neden T ve Codable'ye conform etmesini istiyoruz; biz T type a herhangi bir istediğimiz nesne tipini yollayabiliriz (user, animal ...)
- Bizden parametre olarak bir  endPoint bekleyecek ve bu endPoint EndPoint enumuza bu fonksiyon
- completion bloğunun işlevine gelecek olursak, burada bir ağ isteği olucak
// buraya devam edicem

??? @ESCAPİNG
Bir closure, fonksiyon tamamlandıktan sonra çağrılacaksa, yani fonksiyon çalışmayı bitirdikten sonra bile closure hayatta kalacaksa, closure'ı @escaping ile işaretlemen gerekir. Bu, genellikle asenkron işlemlerde (örneğin, ağ istekleri veya veri tabanı işlemleri gibi uzun süren işlemlerde) kullanılır.

??? Singleton Network Manager
- NetworkManager'ımın instancesini oluşturuyorum singleton şekilde oluşturuyorum neden? !!!!!!!
- Bu yapı, tek bir global erişilebilir NetworkManager örneği oluşturmanı sağlar. Bu sayede
- Tek bir network yöneticisi: Ağ isteklerini yöneten bir sınıf genellikle uygulama boyunca tekrar kullanılmak istenir. NetworkManager'ın sadece bir kez oluşturulup, aynı örneği kullanarak tüm ağ isteklerini yönetmek isteyebilirsin. Her çağırışında yeni bir nesne oluşturmak yerine, tek bir nesneyle tüm ağ işlemlerini yönetebilirsin.
- Bellek yönetimi: Her seferinde yeni bir NetworkManager nesnesi oluşturmak yerine tek bir nesne kullanmak, gereksiz bellek kullanımını önler.
- Merkezi yapı: Singleton yapısı sayesinde NetworkManager'ın merkezi bir yapıda olmasını sağlarsın. Böylece ağ isteği yapılan her yerde aynı NetworkManager kullanılır, farklı örnekler arasında tutarsızlık oluşmaz.
- Global erişim: Uygulamanın farklı yerlerinden NetworkManager'a kolayca erişebilirsin. NetworkManager.shared ile her zaman aynı nesneye ulaşmak mümkündür.
---Özetle---
Bu yapı, tek bir global erişilebilir NetworkManager örneği oluşturmanı sağlar. Bu sayede:
Uygulamanın herhangi bir yerinde aynı NetworkManager nesnesini kullanırsın.
Bellek ve performans açısından avantaj sağlarsın.
Merkezi bir yapı ile network işlemlerini daha kolay yönetirsin.

- Yazmaya devam ediyouz
- Burada let session = URLSession.shared şeklinde bir yapı oluşturudk sebebini anlamadım.
- URLSession.shared.dataTask(with:) işlemi, bir URL'den veri almak veya sunucuya veri göndermek için kullanılan asenkron bir yöntemdir. Bu yöntem, ağ işlemlerini (HTTP istekleri) gerçekleştirmek için yaygın olarak kullanılır ve uygulamanın ana thread'ini (UI thread) bloke etmeden ağ üzerinden veri alıp göndermenize olanak tanır.
- Burada bize bu completion bloğundan dönen data, response, error değerlerinin tamamı nil biz bunları unwrap edeceğiz.
- Burada ilk olarak error ile başlıyoruz burada önemli bir noktaya değeneceğiz CurtomNetwork Errorlarımızı oluşturuyoruz
- Onun dışunda responseCode'larımızın controlünü sağlıyoruz
- status code kontrol içersinde 200 ile 299 arasında bize bir result dönücek ve biz bunu completionda succes durumda döneceğiz.
- Bu bize ara katmandan döncecek direkt olarak requeste VC veya VM üzerinden değil. oluşturduğumuz ara katman üzerinden dönecek ben bunu UserService olarak adlandırıyorum.


* UserService Katmanı *
- Burada direkt olarak bizim user'ımızı çekmemizi sağlayan getUser() fonksiyonumuzu yazıyorum
- Burada artık T type değil json'ımıza uygun olacak şekilde bir User model array'i veriyoruz.
- Ve bu fonksiyon aracılığyla aldığımız endPoint ve complation değerlerini NetworkManager katmanımzda bulunan request' e gönderiyoruz


* Proje Başlatma Adımları *

- Scene Delegate -
- Uygulamnın kullanıcı arayüzünü yönetmekle sorumludur. uygulama başladığında, bir window oluşturur. ve bu pencerenin kök görünüm denetleyicisini (rootViewController) oluşturur.
- Neden önemli? Uygulamanın arayüzünün başlatılmasından ve yaşam döngüsünden sorumlu olduğu için burada kontrol merkezi olarak çalışır. AppRouter'ı kullanarak uygulamanın başlangıç ekranını belirler.


- App Router -
- İşlevi: AppRouter, uygulamanın başlangıç akışını belirlemek için kullanılır. Burada, UserListViewController'ı oluşturur ve bir UINavigationController'ın içine yerleştirir. Bu, uygulamanın ilk görünüm denetleyicisi olur.
- Neden önemli? Router, uygulamanın navigasyon akışını düzenler. Birden fazla ekran arasında geçiş yapmayı kolaylaştırır. Ayrıca, router kullanarak uygulamanın farklı bölümlerini bağımsız olarak yönetmek daha kolaydır.

- AppContainer -
- İşlevi: AppContainer, tüm uygulama genelinde kullanılacak servisler ve router gibi temel bileşenleri barındıran bir "container" (kapsayıcı) yapıdır.
- Neden önemli? Tüm bağımlılıkları (dependency) merkezi bir yerden yönetmeye olanak sağlar. Örneğin, bir servis sınıfı (network servisleri gibi) tek bir yerden kolayca erişilebilir hale gelir.
- Artısı: Uygulama genelinde aynı servis veya router'ı tekrar tekrar oluşturmadan, tek bir yerden erişim sağlayabilirsin. Kod tekrarını önler.


- User Builder -
- İşlevi: UserListBuilder, UserListViewController'ı oluşturur ve içine gerekli olan ViewModeli ekler. Burada, ViewModel servisi kullanarak verileri yönetir.
- Neden önemli? Builder deseni, nesneleri oluştururken bağımlılıkları doğrudan atayarak, bağımlılıkların merkezileşmesine olanak sağlar. Böylece UserListViewController'ın ihtiyaç duyduğu ViewModel ve diğer bileşenler oluşturulur.
- Artısı: Nesne oluşturma işlemleri tek bir yerde yapılır. Eğer kontrolcülerin nasıl oluşturulduğu değiştirilirse, sadece builder'ı güncelleyerek değişiklik yapabilirsin.



* Movie Presentation *

- Presentation yapısı, uygulamalarda veriyi kullanıcıya sunulacak şekilde hazırlayan bir katmandır. Özellikle ViewModel ile View arasındaki iletişimde kullanılır. İşlevlerini şu şekilde sıralayabiliriz

- UI Bağımsızlık Sağlamak:
Presentation katmanı, model verisinin kullanıcı arayüzüne uygun hale getirilmiş temsilidir. Bu sayede model yapısındaki değişiklikler, kullanıcı arayüzünü etkilemez, sadece presentation yapısı güncellenir.

- Test Edilebilirliği Artırmak:
Presentation yapıları, arayüz kodlarından bağımsız oldukları için daha kolay test edilebilir. UI elementleriyle etkileşime girmeden veri manipülasyonunu test edebilirsin.

- Kapsülleme:
Modelin detaylarını gizleyip, sadece gerekli bilgileri View katmanına sunar. Bu, MVC veya MVVM yapılarında katmanlar arası geçişin daha temiz olmasını sağlar.


* CollectionView'mizi oluşturuyoruz *

- İlk olarak bir ext CGFloat için bir extension yazıyoruz.Bu CGFloat extension'ı, ekranın genişliği (dWidth) ve yüksekliği (dHeight) gibi özellikleri daha kolay ve hızlı bir şekilde kullanmana olanak tanır. Kodun içinde her seferinde UIScreen.main.bounds.width ve UIScreen.main.bounds.height yazmak yerine, bu extension sayesinde daha okunabilir ve daha kısa bir kod yazabilirsin.

- CollectionViewHelper oluşturuyoruz, Bu kod, CollectionViewHelper adında bir enum içerisinde, CreateUserListFlowLayout isimli bir statik fonksiyon tanımlıyor. Bu fonksiyon, UICollectionViewFlowLayout nesnesi oluşturup, koleksiyon görünümünde kullanılacak düzen (layout) yapılandırması yapmayı amaçlıyor.

- Şimdi UserListViewController içersinde collectionView'mizi oluşturuyoruz gereken helper ve ext oluşururarak devam ediyoruz.

- UIView için bir ext oluşturuyoruz pinToEdgesOf adında
Bu kod, bir UIView uzantısı (extension) ekleyerek, bir görünümün (UIView'un) kenarlarını başka bir görünüme yapıştırmak (pinlemek) için kolaylaştırılmış bir yöntem oluşturur. Bu uzantı, otomatik düzen (auto layout) kullanarak bir alt görünümün (subview) üst, alt, sol ve sağ kenarlarını üst görünümün (superview) kenarlarına sabitlemeyi sağlar.

- 



